% compatibilité octave/matlab
isOctave = exist('OCTAVE_VERSION', 'builtin') ~= 0;

% la fonction
f=@(x) 1/(1+x^2);
% le domainne de la fonction
domain = -5:0.01:5;

% l'évaluation de f sur le domaine
fedex=arrayfun(@(x) f(x),domain);

plot(domain,fedex)
hold on;

% le nombre de points pris pour l'interpolation
N = [2,4,8];

figure(1);

% génération des interpolations
for n=N
    % équart entre les points
    h=10/n;

    % abscisse des points d'interpolation
    xi = [];
    % ordonée des points d'interpolation
    fxi = [];
    for i=0:n
        xi(i+1) = -5+i*h;
        fxi(i+1) = f(xi(i+1));
    end

    [a,b,c,utile] = polynome_newton(xi,fxi,domain);

    plot(domain,utile);
    
end
    
xlabel('x');
ylabel('y');
title("Polynome d'interpolation de f(x)");
    
if isOctave == 0
nomLeg = compose("P_%d",N);
legend(["f(x)",nomLeg],"Location","best")
else
    % nom des polynomes P_n pour la légende
    nomLeg = arrayfun(@(k) num2str(k),N);
    legend("f(x)",["P_",nomLeg(1)],["P_",nomLeg(2)],["P_",nomLeg(3)])
end

hold off;


N = [2,10,20,30,40];
H=[];
Eh = [];

figure(2);
% génération des interpolations
for n=N
    % équart entre les points
    h=10/n;
    H = [H,h];

    % abscisse des points d'interpolation
    xi = [];
    % ordonée des points d'interpolation
    fxi = [];
    for i=0:n
        xi(i+1) = -5+i*h;
        fxi(i+1) = f(xi(i+1));
    end

    [a,b,c,utile] = polynome_newton(xi,fxi,domain);
    Ex = abs(utile - fedex);
    Eh = [Eh,max(Ex)];
end

semilogy(H,Eh,'-o');
set(gca, 'XDir','reverse')
title("Maximum de l'erreur en fonction de h");
xlabel('h');
ylabel("E(h)");

%Figure 3: f(x) et Q_n(x) pour n=2,4,6
nn=[2,4,6];
figure(3);
hold on;

% Tracer f(x)
plot(domain, fedex, 'k-', 'LineWidth', 1.5);

for n = nn
    if mod(n, 2) ~= 0
        error('n doit être pair pour Q_n.');
    end
    h = 10/n;
    %Les n+1 noeuds pour l'interpolation
    xi = -5:h:5; 
    %La valeur de f à ces noeuds
    fi = arrayfun(f, xi);

    % Initialiser Q_n évalué sur le domaine
    Qn = nan(size(domain));

    %Par block de trois points 1,2,3;3,4,5;5,6,7,etc.
    for i = 1:2:(length(xi)-2)
        % Identifier les points du domaine dans [xi(i), xi(i+2)]
        idx_block = (domain >= xi(i)) & (domain <= xi(i+2));
        dom_block = domain(idx_block);
        % Construire le polynôme de degré 2 via polynome_newton stocker
        % valeur évalué dans utile_block
         [~, ~, ~, utile_block] = polynome_newton(xi(i:i+2), fi(i:i+2), dom_block);
        
        % Insérer dans Q_n
        Qn(idx_block) = utile_block;
    end
    % Tracer Q_n
    plot(domain, Qn, 'LineWidth', 1.2);
end

xlabel('x');
ylabel('y');
title('Interpolation quadratique par morceaux Q_n(x)');

% Légende compatible Matlab/Octave
if isOctave == 0
    nomLeg = compose("Q_%d", nn);
    legend(["f(x)", nomLeg], 'Location', 'best');
else
    nomLeg = arrayfun(@(k) sprintf('Q_%d', k), nn, 'UniformOutput', false);
    legend(['f(x)', nomLeg{:}], 'Location', 'best');
end
hold off;

% Figure 4 E(h) en fonction de h. Interpolation quadratique
Nq=[2,10,20,30,40,50];

%Initialisation de h
Hq = zeros(size(Nq));

%Initialisation de E(h)
Eq = zeros(size(Nq));

figure(4);
hold on;

for k = 1:length(Nq)
    n = Nq(k);
    if mod(n, 2) ~= 0
        error('n doit être pair pour Q_n.');
    end


    
end
